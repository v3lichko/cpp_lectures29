\documentclass[12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{ulem}

\geometry{
    a4paper,
    total={547pt, 770pt},
    left=25pt,
    top=25pt
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan
}

\setcounter{secnumdepth}{-1}

\begin{document}

\title{C++. Первый курс. Теоретический минимум.\\[4pt] Лабораторная работа №1}
\author{Группа М3109}
\date{}
\maketitle

\section{1. Стандартные типы данных и представление чисел в памяти}

По Бьёрну Страуструпу, \textbf{фундаментальные типы данных} --- это базовые типы, которые гарантированно есть в языке C++.

\subsection*{1) \texttt{int}}
Тип \texttt{int} представляет целое число, обычно занимает \textbf{4 байта} (32 бита).  
Диапазон значений:
\[
[-2^{31},\ 2^{31}-1]
\]
(то есть от \texttt{-2147483648} до \texttt{2147483647}).

\paragraph{Дополнительный код (two's complement).}
Это способ представления отрицательных чисел в памяти.

\begin{itemize}
    \item Старший бит — \textbf{знаковый} (0 — положительное, 1 — отрицательное число).
    \item Чтобы получить отрицательное число $-X$, нужно:
    \begin{enumerate}
        \item инвертировать все биты $X$ (заменить 0 на 1 и наоборот);
        \item прибавить 1.
    \end{enumerate}
\end{itemize}

Так как один бит занят под знак, остаётся 31 бит для значения, что даёт диапазон:
\[
[-2^{31},\ 2^{31}-1].
\]


\subsection*{2) \texttt{long}}
Тип \texttt{long} может занимать \textbf{4 или 8 байт} в зависимости от архитектуры (32- или 64-битной).  
Используется редко, поскольку его размер нефиксирован. В современных программах предпочтительно использовать \texttt{int} или \texttt{long long}.

\subsection*{3) \texttt{long long}}
Тип \texttt{long long} занимает \textbf{8 байт} (64 бита).  
Диапазон значений:
\[
[-2^{63},\ 2^{63}-1].
\]

\subsection*{4) \texttt{char}}
Тип \texttt{char} — это \textbf{целочисленный тип}, занимающий ровно 1 байт.  
Может быть:
\begin{itemize}
    \item \texttt{signed char}: диапазон \texttt{[-128, 127]};
    \item \texttt{unsigned char}: диапазон \texttt{[0, 255]}.
\end{itemize}

С ним можно выполнять арифметические операции, но важно учитывать возможное переполнение.

\subsection*{5) \texttt{float}}
Тип с плавающей точкой, занимает \textbf{4 байта}.  
Примерный диапазон:
\[
\pm 1.4\times10^{-45} \text{ до } \pm 3.4\times10^{38},
\]
точность --- около 6–9 значащих цифр.

\subsection*{6) \texttt{double}}
Тип с плавающей точкой двойной точности, занимает \textbf{8 байт}.  
Диапазон:
\[
\pm 4.9\times10^{-324} \text{ до } \pm 1.8\times10^{308},
\]
точность — около 15–17 значащих цифр.

\paragraph{Стандарт IEEE 754.}
\begin{itemize}
    \item \textbf{float (32 бита):}  
    \texttt{S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM}  
    1 бит — знак, 8 бит — экспонента, 23 бита — мантисса.
    \item \textbf{double (64 бита):}  
    \texttt{S EEEEEEEEEEE MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM}  
    1 бит — знак, 11 бит — экспонента, 52 бита — мантисса.
\end{itemize}

При арифметических операциях значения \texttt{float} часто неявно преобразуются к \texttt{double}.

\subsection*{7) \texttt{long double}}
Тип расширенной точности, занимает \textbf{не менее 8 байт} (на практике 10, 12 или 16 байт в зависимости от реализации).

\subsection*{8) \texttt{bool}}
Тип логического значения, может быть только \texttt{true} или \texttt{false}.  
Занимает \textbf{1 байт} (1 бит технически невозможен из-за архитектурных ограничений).

\subsection*{Модификатор \texttt{unsigned}}
Для целочисленных типов можно добавить модификатор \texttt{unsigned} — это убирает знак числа.  
Например:
\[
\texttt{unsigned int: } [0, 2^{32}-1]
\]
Весь диапазон значений используется для неотрицательных чисел.
Стоит отметить , что при переполнении , знаковые типы хранят в себе мусор , а беззнаковые берут остаток от деления от своего максимального значения
\section{2. Литералы}

\textbf{Литерал} — это последовательность символов, обозначающая константное значение. Примеры:

\begin{itemize}
    \item \texttt{1} — целочисленный литерал;
    \item \texttt{'a'} — символьный;
    \item \texttt{"abc"} — строковый;
    \item \texttt{0.2f} — вещественный (\texttt{float});
    \item \texttt{true}, \texttt{false}, \texttt{nullptr} , \texttt{\}} — специальные литералы.
\end{itemize}

\paragraph{Неявные преобразования.}
Некоторые типы могут неявно преобразовываться:
\begin{itemize}
    \item \texttt{double → int}, \texttt{char → int}, \texttt{int → bool} и т.д.
\end{itemize}

Например:
\begin{itemize}
    \item \texttt{int x = 5.0;} — корректно, \texttt{5.0} приводится к \texttt{int};
    \item \texttt{5 / 3 = 1}, но \texttt{5 / 3.} даёт \texttt{1.666...}.
\end{itemize}

\paragraph{Суффиксы литералов.}
Постфикс (суффикс) уточняет тип:
\[
\texttt{1U} \rightarrow \texttt{unsigned int}, \quad \texttt{3.14f} \rightarrow \texttt{float}.
\]

\section{3. Массивы}

Массивы объявляются так:
\[
\texttt{type name[количество\_элементов];}
\]
Доступ к элементу осуществляется по индексу: \texttt{a[i]}.

\begin{itemize}
    \item Индексация начинается с 0.
    \item Размер массива должен быть фиксирован на момент компиляции (для статических массивов).
    \item При выходе за пределы массива программа получает ошибку времени выполнения (\texttt{RE}) или сегфолт (\texttt{Segmentation Fault}).
\end{itemize}

\paragraph{Расположение в памяти.}
Элементы массива хранятся последовательно.  

При запуске программы массив, объявленный в функции, располагается в стеке, а динамически созданный — в куче.

\medskip
При запуске программы часть памяти забирает ОС — там хранится техническая информация, исполняемый код и прочее.  
Если мы объявили \texttt{int x}, в стеке выделяется 4 байта, по адресу которых лежит значение \texttt{x}.  
Далее в области видимости могут появляться и исчезать переменные, и освобождённые байты переиспользуются под другие данные.

Если объявить массив \texttt{int a[100]}, то это сплошные 400 байт памяти.  
Когда мы пишем \texttt{a[5]}, программа делает 5 шагов вправо от начала массива, размер шага — размер типа (4 байта).  
Отсюда становится понятна нулевая индексация.

\section{Указатели}

Указатель — это тип данных, который служит для представления адресов в памяти.  
Объявляется так:
\begin{verbatim}
int* x;
\end{verbatim}

\texttt{int*} — это тип «указатель на \texttt{int}», то есть адрес памяти, по которому лежит целое число.

С указателями можно смотреть, что под ними лежит, с помощью унарной звёздочки — оператора разыменования:
\begin{verbatim}
int* x;
*x;
\end{verbatim}

Это значит: возьми указатель и верни то, что под ним лежит.  
Можно писать и \texttt{int *x}, разницы нет — это вкусовщина.

\paragraph{Адрес переменной.}
\begin{verbatim}
int b;
int *y = &b;
\end{verbatim}

Унарный амперсанд \texttt{\&} берёт адрес переменной.  
Рекомендуется поэкспериментировать, чтобы привыкнуть.

\paragraph{Арифметика указателей.}
Указатели можно инкрементировать, декрементировать и вычитать друг из друга.  
Например:
\begin{verbatim}
int *x;
x = x + 5;
\end{verbatim}

Это означает: сделать 5 шагов вправо по типу \texttt{int} (то есть на 20 байт).  
Выражения \texttt{+=}, \texttt{-=}, \texttt{++}, \texttt{--} работают аналогично.

\paragraph{Разность указателей.}
Разность двух указателей — это количество элементов (шагов) между ними.

\paragraph{Связь с массивами.}
Выражение \texttt{a[i]} эквивалентно \texttt{*(a + i)}.  
Поскольку операция коммутативна, \texttt{5[a]} тоже корректно!

Можно делать массивы из указателей на что угодно.

\paragraph{Динамическая память.}
Если нужно создать большой массив (больше, чем позволяет стек), используют \textbf{динамическую память} с помощью операторов \texttt{new} и \texttt{delete}.  
Это выходит за рамки теоретического минимума.


\section{Функции}

Функция — это именованный блок кода, который можно вызвать многократно (не все виды — лямбду только один раз).  
У функции есть сигнатура — тип, аргументы и название, и есть тело (код в фигурных скобках).

Когда мы вызываем функцию, происходит инициализация параметров значениями аргументов.  
После завершения работы функции переменные внутри неё уничтожаются из-за области видимости.  
Оператор \texttt{return} возвращает результат выполнения функции, и его тип должен совпадать с типом функции.  
Если функция ничего не возвращает — она имеет тип \texttt{void}.

\section{Указатель на функцию}

Функция, определённая в программе, тоже хранится в памяти (в виде инструкций).  
Чтобы получить её адрес, можно написать:
\begin{verbatim}
p = &f;
\end{verbatim}

\paragraph{Пример:}
\begin{verbatim}
int foo(double a, char* b) { return int(a); }
int (*p)(double, char*) = &foo;
\end{verbatim}

Тип переменной \texttt{p} должен полностью соответствовать типу функции.

\texttt{main} нельзя брать по адресу.

\paragraph{Особый случай:}
\texttt{void*} — это указатель общего назначения, но его нельзя разыменовать.

\paragraph{Итог:}
Указатель на функцию — это переменная, которая хранит адрес функции в памяти и позволяет вызывать её косвенно.

\end{document}

