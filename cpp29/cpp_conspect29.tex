\documentclass[12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{ulem}

\geometry{
    a4paper,
    total={547pt, 770pt},
    left=25pt,
    top=25pt
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan
}

\setcounter{secnumdepth}{-1}

\begin{document}

\title{C++. Первый курс. Теоретический минимум.\\[4pt] Лабораторная работа №1}
\author{Группа М3109}
\date{}
\maketitle

\section{1. Стандартные типы данных и представление чисел в памяти}

По Бьёрну Страуструпу, \textbf{фундаментальные типы данных} --- это базовые типы, которые гарантированно есть в языке C++.

\subsection*{1) \texttt{int}}
Тип \texttt{int} представляет целое число, обычно занимает \textbf{4 байта} (32 бита).  
Диапазон значений:
\[
[-2^{31},\ 2^{31}-1]
\]
(то есть от \texttt{-2147483648} до \texttt{2147483647}).

\paragraph{Дополнительный код (two's complement).}
Это способ представления отрицательных чисел в памяти.

\begin{itemize}
    \item Старший бит — \textbf{знаковый} (0 — положительное, 1 — отрицательное число).
    \item Чтобы получить отрицательное число $-X$, нужно:
    \begin{enumerate}
        \item инвертировать все биты $X$ (заменить 0 на 1 и наоборот);
        \item прибавить 1.
    \end{enumerate}
\end{itemize}

Так как один бит занят под знак, остаётся 31 бит для значения, что даёт диапазон:
\[
[-2^{31},\ 2^{31}-1].
\]


\subsection*{2) \texttt{long}}
Тип \texttt{long} может занимать \textbf{4 или 8 байт} в зависимости от архитектуры (32- или 64-битной).  
Используется редко, поскольку его размер нефиксирован. В современных программах предпочтительно использовать \texttt{int} или \texttt{long long}.

\subsection*{3) \texttt{long long}}
Тип \texttt{long long} занимает \textbf{8 байт} (64 бита).  
Диапазон значений:
\[
[-2^{63},\ 2^{63}-1].
\]

\subsection*{4) \texttt{char}}
Тип \texttt{char} — это \textbf{целочисленный тип}, занимающий ровно 1 байт.  
Может быть:
\begin{itemize}
    \item \texttt{signed char}: диапазон \texttt{[-128, 127]};
    \item \texttt{unsigned char}: диапазон \texttt{[0, 255]}.
\end{itemize}

С ним можно выполнять арифметические операции, но важно учитывать возможное переполнение.

\subsection*{5) \texttt{float}}
Тип с плавающей точкой, занимает \textbf{4 байта}.  
Примерный диапазон:
\[
\pm 1.4\times10^{-45} \text{ до } \pm 3.4\times10^{38},
\]
точность --- около 6–9 значащих цифр.

\subsection*{6) \texttt{double}}
Тип с плавающей точкой двойной точности, занимает \textbf{8 байт}.  
Диапазон:
\[
\pm 4.9\times10^{-324} \text{ до } \pm 1.8\times10^{308},
\]
точность — около 15–17 значащих цифр.

Число с плавающей точкой состоит из трёх основных компонентов:

\begin{itemize}
    \item \textbf{Знак} ($S$) — один бит, указывающий знак всего числа
    \item \textbf{Порядок} ($E$) — целое число, определяет масштаб
    \item \textbf{Мантисса} ($M$) — целое число, определяет точность
\end{itemize}

\subsection*{Математическое представление}

Число представляется в виде:

\[
(-1)^S \times M \times B^E
\]

где:
\begin{itemize}
    \item $S$ — знак (0 для положительных, 1 для отрицательных)
    \item $B$ — основание системы счисления (обычно 2 или 10)
    \item $E$ — порядок (экспонента)
    \item $M$ — мантисса
\end{itemize}

\subsection*{Связь с научной нотацией}

Десятичное число в научной нотации записывается как:
\[
R \times 10^E
\]
где $R$ — число в полуинтервале $[1; 10)$.

В нормализованной форме:
\begin{itemize}
    \item Модуль $|R|$ становится мантиссой $M$
    \item $E$ становится порядком
    \item $S = 1$ тогда и только тогда, когда $R < 0$
\end{itemize}

\subsection*{Пример}

Число $-3.5$ в нормализованной форме:
\[
-3.5 = (-1)^1 \times 3.5 \times 10^0
\]
где:
\begin{itemize}
    \item $S = 1$ (отрицательное число)
    \item $M = 3.5$ (мантисса)
    \item $B = 10$ (основание)
    \item $E = 0$ (порядок)
\end{itemize}

\subsection*{Терминология}

\begin{itemize}
    \item \textbf{Порядок} также называют \textbf{экспонентой}
    \item \textbf{Показатель степени} — синоним порядка
    \item \textbf{Нормализованная форма} — когда мантисса находится в определённом диапазоне
\end{itemize}
\paragraph{Стандарт IEEE 754.}
\begin{itemize}
    \item \textbf{float (32 бита):}  
    \texttt{S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM}  
    1 бит — знак, 8 бит — экспонента, 23 бита — мантисса.
    \item \textbf{double (64 бита):}  
    \texttt{S EEEEEEEEEEE MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM}  
    1 бит — знак, 11 бит — экспонента, 52 бита — мантисса.
\end{itemize}
При арифметических операциях значения \texttt{float} часто неявно преобразуются к \texttt{double}.

\subsection*{7) \texttt{long double}}
Тип расширенной точности, занимает \textbf{не менее 8 байт} (на практике 10, 12 или 16 байт в зависимости от реализации).

\subsection*{8) \texttt{bool}}
Тип логического значения, может быть только \texttt{true} или \texttt{false}.  
Занимает \textbf{1 байт} (1 бит технически невозможен из-за архитектурных ограничений).

\subsection*{Модификатор \texttt{unsigned}}
Для целочисленных типов можно добавить модификатор \texttt{unsigned} — это убирает знак числа.  
Например:
\[
\texttt{unsigned int: } [0, 2^{32}-1]
\]
Весь диапазон значений используется для неотрицательных чисел.
Стоит отметить , что при переполнении , знаковые типы хранят в себе мусор , а беззнаковые берут остаток от деления от своего максимального значения
\section{2. Литералы}

\textbf{Литерал} — это последовательность символов, обозначающая константное значение. Примеры:

\begin{itemize}
    \item \texttt{1} — целочисленный литерал;
    \item \texttt{'a'} — символьный;
    \item \texttt{"abc"} — строковый;
    \item \texttt{0.2f} — вещественный (\texttt{float});
    \item \texttt{true}, \texttt{false}, \texttt{nullptr} , \texttt{\}} — специальные литералы.
\end{itemize}

\paragraph{Неявные преобразования.}
Некоторые типы могут неявно преобразовываться:
\begin{itemize}
    \item \texttt{double → int}, \texttt{char → int}, \texttt{int → bool} и т.д.
\end{itemize}

Например:
\begin{itemize}
    \item \texttt{int x = 5.0;} — корректно, \texttt{5.0} приводится к \texttt{int};
    \item \texttt{5 / 3 = 1}, но \texttt{5 / 3.} даёт \texttt{1.666...}.
\end{itemize}

\paragraph{Суффиксы литералов.}
Постфикс (суффикс) уточняет тип:
\[
\texttt{1U} \rightarrow \texttt{unsigned int}, \quad \texttt{3.14f} \rightarrow \texttt{float}.
\]

\section{3. Массивы}

Массивы объявляются так:
\[
\texttt{type name[количество\_элементов];}
\]
Доступ к элементу осуществляется по индексу: \texttt{a[i]}.

\begin{itemize}
    \item Индексация начинается с 0.
    \item Размер массива должен быть фиксирован на момент компиляции (для статических массивов).
    \item При выходе за пределы массива программа получает ошибку времени выполнения (\texttt{RE}) или сегфолт (\texttt{Segmentation Fault}).
\end{itemize}

\paragraph{Расположение в памяти.}
Элементы массива хранятся последовательно.  

При запуске программы массив, объявленный в функции, располагается в стеке, а динамически созданный — в куче.

\medskip
При запуске программы часть памяти забирает ОС — там хранится техническая информация, исполняемый код и прочее.  
Если мы объявили \texttt{int x}, в стеке выделяется 4 байта, по адресу которых лежит значение \texttt{x}.  
Далее в области видимости могут появляться и исчезать переменные, и освобождённые байты переиспользуются под другие данные.

Если объявить массив \texttt{int a[100]}, то это сплошные 400 байт памяти.  
Когда мы пишем \texttt{a[5]}, программа делает 5 шагов вправо от начала массива, размер шага — размер типа (4 байта).  
Отсюда становится понятна нулевая индексация.

\section{Указатели}

Указатель — это тип данных, который служит для представления адресов в памяти.  
Объявляется так:
\begin{verbatim}
int* x;
\end{verbatim}

\texttt{int*} — это тип «указатель на \texttt{int}», то есть адрес памяти, по которому лежит целое число.

С указателями можно смотреть, что под ними лежит, с помощью унарной звёздочки — оператора разыменования:
\begin{verbatim}
int* x;
*x;
\end{verbatim}

Это значит: возьми указатель и верни то, что под ним лежит.  
Можно писать и \texttt{int *x}, разницы нет — это вкусовщина.

\paragraph{Адрес переменной.}
\begin{verbatim}
int b;
int *y = &b;
\end{verbatim}

Унарный амперсанд \texttt{\&} берёт адрес переменной.  
Рекомендуется поэкспериментировать, чтобы привыкнуть.

\paragraph{Арифметика указателей.}
Указатели можно инкрементировать, декрементировать и вычитать друг из друга.  
Например:
\begin{verbatim}
int *x;
x = x + 5;
\end{verbatim}

Это означает: сделать 5 шагов вправо по типу \texttt{int} (то есть на 20 байт).  
Выражения \texttt{+=}, \texttt{-=}, \texttt{++}, \texttt{--} работают аналогично.

\paragraph{Разность указателей.}
Разность двух указателей — это количество элементов (шагов) между ними.

\paragraph{Связь с массивами.}
Выражение \texttt{a[i]} эквивалентно \texttt{*(a + i)}.  
Поскольку операция коммутативна, \texttt{5[a]} тоже корректно!

Можно делать массивы из указателей на что угодно.

\paragraph{Динамическая память.}
Если нужно создать большой массив (больше, чем позволяет стек), используют \textbf{динамическую память} с помощью операторов \texttt{new} и \texttt{delete}.  
Это выходит за рамки теоретического минимума.


\section{Функции}

Функция — это именованный блок кода, который можно вызвать многократно (не все виды — лямбду только один раз).  
У функции есть сигнатура — тип, аргументы и название, и есть тело (код в фигурных скобках).

Когда мы вызываем функцию, происходит инициализация параметров значениями аргументов.  
После завершения работы функции переменные внутри неё уничтожаются из-за области видимости.  
Оператор \texttt{return} возвращает результат выполнения функции, и его тип должен совпадать с типом функции.  
Если функция ничего не возвращает — она имеет тип \texttt{void}.

\section{Указатель на функцию}

Функция, определённая в программе, тоже хранится в памяти (в виде инструкций).  
Чтобы получить её адрес, можно написать:
\begin{verbatim}
p = &f;
\end{verbatim}

\paragraph{Пример:}
\begin{verbatim}
int foo(double a, char* b) { return int(a); }
int (*p)(double, char*) = &foo;
\end{verbatim}

Тип переменной \texttt{p} должен полностью соответствовать типу функции.

\texttt{main} нельзя брать по адресу.

\paragraph{Особый случай:}
\texttt{void*} — это указатель общего назначения, но его нельзя разыменовать.

\paragraph{Итог:}
Указатель на функцию — это переменная, которая хранит адрес функции в памяти и позволяет вызывать её косвенно.


\section{Структуры:}
Структура это один из способов создать свой тип данных , синтаксис у нее такой 
\begin{verbatim}
    Struct [name]{
    [поле структуры];
    [поле структуры];
    };
\end{verbatim}
Поле структуры - данные , которые хранятся в структуре , условно :
\begin{verbatim}
    Struct S{
    int x=1;
    char c;
    double d;
    };
\end{verbatim}
Стоит отметить , что при ее инициализации в конце стоит поставить ; , что выглядит довольно специфично . На примере видим , что поля структуры мы можем проинициализировать по умолчанию , если мы делаем так , то при создании структуры у нас будет конкретное поле проинициализированно , в остальных же будет мусор , также можно сделать вот так :
\begin{verbatim}
    S s{2 , 'a' , 2.14};//агрегатная инициализация 
\end{verbatim}
При такой инициализации обязательно нужно обращать внимание на последовательность типов , иначе мы будем падать по Compile Error , также ,если у нас какие то поля проинициализированы по умолчанию , можно делать так :
\begin{verbatim}
    S s{'a' , 2.14}
\end{verbatim}
И это будет работать . Мы обращаемся к полям структуры следующим образом : 
\begin{verbatim}
    s.x = 2;
    s.c='b';
    s.d;
\end{verbatim}
Таким же образом можем присваивать значения и все такое , также это работает и для вывода через
\begin{verbatim}
    std::cout<<s.x<<s.d;
\end{verbatim}
Если же мы хотим использовать указатель на структуру , то можно обращаться через оператор -> , следующим образом : 
\begin{verbatim}
    S* ps = new S{2};
    std::cout<<*ps.x<<" "<< ps.c <<" "<< ps.d <<'\n';
    std::cout<<ps->x<<" "<< ps.c <<" "<< ps.d <<'\n';
\end{verbatim}
Выводы будут такие же , следовательно стрелочка это разыменование и обращение к полю.
Помимо полей мы можем объявлять в структурах методы , это операции , которые мы можем применить к структуре .Пример :
\begin{verbatim}
    Struct s{
    int x = 1;
    double y = 1.1;
    char c = 'F';
    void f(){
    std::cout<<x<<" "<<y<<" "<<c<<'\n';
    }
    };
    int main(){
    S s{2};
    s.f();
    }
\end{verbatim}
Тут все вроде как понятно , в структуре мы храним какие то поля , следовательно методы имеют к ним доступ и в сигнатуре не нужно их прописывать . Экземпляры структуры , т.е. в нашем случае s , нразываются объектами . Помимо этого , в метод мы также можем передать какие то параметры в сигнатуру  , например :
\begin{verbatim}
        Struct s{
    int x = 1;
    double y = 1.1;
    char c = 'F';
    void f(int z){
    std::cout<<x<<" "<<y<<" "<<c<<" "<<z<<'\n';
    }
    void foo(int x){
    std::cout<<x <<" "<< this->x <<'\n'
    }
    };
    int main(){
    S s{2};
    s.f(3);
    s.foo(5);
    }
\end{verbatim}
Тогда у нас закрадывается вопрос , что если в поле структуры у нас будет наименованна та же переменная , что мы хотим передать в метод ? Смотрим на пример и видим ключевое слово this , это слово позволяет нам явно обращаться к указателю на данный объект из его тела , в примере мы находимся в теле нашей структурки , далее мы явно обращаемся к нашей структуре через указатель , используя this и стрелочкой разыменовываем и обращаемся к конкретному полю нашей структуры.Методы в структурах видят друг друга всегда , то есть разницы нет в каком порядке мы их объявляем и нам в целом не нужен прием forward declaration , также мы можем делать перегрузку методов , посмотрим на пример : 
\begin{verbatim}
        Struct s{
    int x = 1;
    double y = 1.1;
    char c = 'F';
    void f(int z){
    std::cout<<x<<" "<<y<<" "<<c<<" "<<z<<'\n';
    }
    void foo(int x){
    std::cout<<x <<" "<< this->x <<'\n';
    }
    void foo(){
    std::cout<<"Fyodor Kurilov"<<'\n';
    }
    };
    int main(){
    S s{2};
    s.f(3);
    s.foo(5);
    s.foo();
    }
\end{verbatim}
И у нас все прекрасно работает ! Мы помимо всего прочего можем объявлять метод внутри структуры и определять вне ее , выглядит это так :
\begin{verbatim}
            Struct s{
    int x = 1;
    double y = 1.1;
    char c = 'F';
    void f(int z){
    std::cout<<x<<" "<<y<<" "<<c<<" "<<z<<'\n';
    }
    void foo(int x){
    std::cout<<x <<" "<< this->x <<'\n';
    }
    void foo(){
    std::cout<<"Fyodor Kurilov"<<'\n';
    }
    void cpp();
    };
    void S::cpp(){
    cout<<"CPP"<<'\n';
    }
    int main(){
    S s{2};
    s.f(3);
    s.foo(5);
    s.foo();
    }
\end{verbatim}
И вот это определение метода вне структуры никак нам не накладывает ограничения , наш метод по прежнему видит все ее поля и другие методы . Мы можем внутри структур объявлять другие структуры и эти структуры будут называться inner structers , то есть внутренние структуры , пример : 
\begin{verbatim}
    Struct S{
    int x = 1;
    Struct SS{
    double d = 1.1;
    };
    };
    int main(){
    S::SS ss;
    }
\end{verbatim}
Из вне мы тоже можем увидеть эту структуру , но мы должны явно указать , октуда мы ее достаем . Поля инициализируются в порядке объявления.Мы можем делать очень много разных вещей с внутренней структурой , SS будет таким же объектом как и S , следовательно мы можем делать с ним все тоже самое , что из S , единственное отличие в том , что чтобы достать SS нам надо обязательно указывать явно откуда мы берем это . Условно : 
\begin{verbatim}
    Struct S{
    int x = 1;
    Struct SS{
    double d = 1.1;
    int y = x;
    };
    };
    int main(){
    S::SS ss;
    }
\end{verbatim}
Не будет работать , потому что , хоть у нас и SS лежит в S  , но это не говорит нам о том , что они как-то связаны . Связаны они только тем , что чтобы создать SS , мы обязаны обратиться к S , чтобы мы смогли увидеть , что у нас есть SS .\\
Продолжим дальше , еще можно объявлять и определятьь структуры внутри функций , фнукции внутри функций нельзя , структуры внутри структуры можно и структуру внутри функции тоже можно !
\begin{verbatim}
    Struct S{
    int x = 1;
    Struct SS{
    double d = 1.1;
    int y = x;
    };
    };
    void g(){
    struct Another{
    int a = 1;
    int b = 2;
    };
    Another a;
    S::SS ss;
    }
    int main(){
    g();
    }
\end{verbatim}
будет работать , это называется локальные структуры , если они внутри функций . Еще моментик про размер структуры S , мне лень писать пример и контр пример , но если мы выведем размер S , у которого лежит внутри SS и потом выведем размер S и закомментим SS , то размер у нас будет одинаковый , также размер структуры зависит от того , в каком порядке мы перечисляем поля , потому что поля кладутся подряд , но допустим переменные типа double мы можем ложить только по адресу кратному 8 , в отношении полей компилятор не имеет права их переупорядочивать , т.е. мы ложим все подряд , но компилятор решает пропускать или нет какие то куски памяти , пример:
\begin{verbatim}
    Struct S{
    int x = 1;
    char c = 'a';
    double y = 3.14;
    }
    Struct SS{
    int x = 1;
    double y = 3.14;
    char c = 'a';
    }
\end{verbatim}
Эти структуры будут весить по разному , сейчас разберемся . Как лежит в памяти структура S : сначала ложим 4 байта под x , потом 1 байт под c , потом нам нужно пропустить 3 байта и только потом мы можем ложить y , поскольку double мы можем класть только в адреса памяти кратные 8 ! Итого у нас S весит 16 байт . Теперь про SS , мы ложим 4 байта под x , потом пропускаем 4 байта ложим double , но размер его 24 ... почему так ? Дело в том , что память округляется дл наибольшего поля , следовательно мы исходим из того , что следующую SS мы должны положить впритык к предыдущей , поэтому компилятор дополняет до 8 байт , для того чтобы следующая SS лежало сразу за прошлой или намного проще понять его работу можно так . Мы смотрим наибольший тип в случае SS это double , т.е. 8 байт , потом мы заполняем все и выходит 17 байт , далее мы должны найти такое число , чтобы оно было больше или равно 17 и делилось на 8 и жто будет его размер ! . Мы ложим х , это 4 байта , дополняем 4 байта для у и ложим его , итого 4+4+8 = 16 байт и ложим с и становится 17 байт , далее находим число больше или равное 17 и кратное 8 и это 24 . \\
Теперь поговорим о неименованных структурах , т.е. 
\begin{verbatim}
    Struct s{
    struct {
    int x = 1;
    double y = 2;
    };
    int x = 2;
    };
    int main(){
    std::cout<<s.x<<" "; \\ error : duplicate member;
    \\сделаем вид , что сейчас мы закоменитили строку int x = 2;
    std::cout<<s.x<<" ";
    }
\end{verbatim}
обращение вот так не будет работать , поскольку компилятор ничего не понимает . Поэтому стоит обращаться вот так :
\begin{verbatim}
        struct s{
    struct {
    int x = 1;
    double y = 2;
    };
    //int x = 2;
    };
    int main() {
    s obj;
    std::cout << obj.x << " " << obj.y;
}

\end{verbatim}
и это работает !!!
\paragraph{Обьединения}
Обьединения это union , суть работы примерна та же , что и у структур , но делаем исключение для работы с памятью . Все поля обьединения делят одно и то же место в памяти . Синтаксис такой же 
\begin{verbatim}
    union [name] {
    [поле];
    [поле];
};
\end{verbatim}
Размер union равен размеру самого большого поля (с учётом выравнивания);
В каждый момент времени активно только одно поле — то, которое мы записали последним;
Если мы перезаписываем одно поле, другие меняются (или становятся мусором),
так как память у них общая.Пример : 
\begin{verbatim}
    union U {
    int x;
    double y;
};

int main() {
    U u;
    u.x = 10;                 // Записали int
    std::cout << u.x << '\n'; // 10
    u.y = 3.14;               // Записали double
    std::cout << u.y << '\n'; // 3.14
    std::cout << u.x << '\n'; // мусор, потому что память общая
}
\end{verbatim}
То есть мы не можем инициализироватт сразу несколько полей , поскольку память общая )) 
Теперь посмотрим на это 
\begin{verbatim}
    union U {
    int a;     // 4 байта
    char c;    // 1 байт
    double d;  // 8 байт
};
int main() {
    std::cout << sizeof(U); // 8
}
\end{verbatim}
Размер union будет просто максимальным размером его поля . Указатели и доступ работают ровно также , с this , стрелочками и всем таким , даже еще можно делать методы внутри юниона , но у этих методах не должно быть конструктора или конструктора не по умолчанию , так было до С++11 , но теперь мы можем делать даже конструкторы и деструкторы , но нужно вручную управлять временем жизни полей с помощью placement new и явного вызова деструктора, теперь примеры : 
\begin{verbatim}
    union U {
    int x;
    double y;
};

int main() {
    U u;
    U* pu = &u;
    pu->x = 42;
    std::cout << pu->x << '\n';
}
\end{verbatim}
тут все ок , это так реально работает
\begin{verbatim}
    #include <string>
#include <iostream>

union Data {
    int i;
    std::string s; // ok в C++11 и выше

    Data() { new(&s) std::string("Hello"); }
    ~Data() { s.~basic_string(); }
};
\end{verbatim}
это также работает ! можно это тоже комбинировать , см. пример 
\begin{verbatim}
    struct S {
    int type;
    union {
        int i;
        double d;
        char c;
    };
};

int main() {
    S s;
    s.type = 1;
    s.i = 42;
    std::cout << s.i << '\n';
}
\end{verbatim}
тут просто смотрите как можно делать все это вместе ! короче итого:
union хранит все поля в одной памяти;
используется, когда нужно сэкономить память или интерпретировать одни и те же биты по-
разному;
размер равен наибольшему полю;
можно использовать анонимно внутри struct;
до C++11 — только тривиальные типы, с C++11 — можно управлять объектами вручную;
методы, указатели и инициализация работают аналогично struct.

\end{document}




